1.抽象类
 通过在类定义前面放置关键字 abstract，可以将类声明为抽象类，不能实例化。抽象类的用途是提供一个可供多个派生类共享的通用基类定义。抽象类也可以定义抽象方法。方法是将关键字 abstract 添加到方法的返回类型的前面。抽象方法没有实现，所以方法定义后面是分号，而不是常规的方法块。
    抽象类的派生类必须实现所有抽象方法。当抽象类从基类继承虚方法时，抽象类可以使用抽象方法重写该虚方法。如果将 virtual 方法声明为 abstract，则该方法对于从抽象类继承的所有类而言仍然是虚方法。继承一个抽象方法的类不能访问该方法的原始实现。在上一个示例中，类 F 中的 DoWork ()不能调用类 D 中的DoWork()。通过这种方式，抽象类可以强制派生类为虚方法提供新的方法实现。
public class D
{
    public virtual void DoWork(int i)
    {
        // Original implementation.
    }
}
public abstract class E : D
{
    public abstract override void DoWork(int i);
}
public class F : E
{
    public override void DoWork(int i)
    {
        // New implementation.
    }
}
2.密封类
通过在类定义前面放置关键字 sealed，可以将类声明为密封类。密封类不能用作基类。因此，它也不能是抽象类。密封类禁止派生。由于密封类从不用作基类，所以有些运行时优化可以略微提高密封类成员的调用速度。在对基类的虚成员进行重写的派生类上，方法、索引器、属性或事件可以将该成员声明为密封成员。在用于以后的派生类时，这将取消成员的虚效果。方法是在类成员声明中将 sealed 关键字置于 override 关键字的前面。
    public sealed class D
    {
    // Class members here.
    }
  
   public class D : C
    {
    public sealed override void DoWork() { }
    }
3.静态类
静态类与非静态类基本相同，但存在一个区别：静态类不能实例化。 也就是说，不能使用 new 关键字创建静态类类型的变量。 因为没有实例变量，所以要使用类名本身访问静态类的成员。 对于只对输入参数进行运算而不获取或设置任何内部实例字段的方法集，静态类可以方便地用作这些方法集的容器。
   和所有类类型一样，当加载引用静态类的程序时，.NET Framework 公共语言运行时 (CLR) 将加载该静态类的类型信息。程序不能指定加载静态类的确切时间。 但是，可以保证在程序中首次引用该类前加载该类，并初始化该类的字段并调用其静态构造函数。 静态构造函数仅调用一次，在程序驻留的应用程序域的生存期内，静态类一直保留在内存中。
   介绍静态类的主要特性：
仅包含静态成员。 
无法实例化。 
是密封的。 
不能包含实例构造函数。
    因此，创建静态类与创建仅包含静态成员和私有构造函数的类基本相同。私有构造函数阻止类被实例化。 使用静态类的优点在于，编译器能够执行检查以确保不致偶然地添加实例成员。编译器将保证不会创建此类的实例。静态类是密封的，因此不可被继承。 它们不能从除 Object 外的任何类中继承。静态类不能包含实例构造函数，但可以包含静态构造函数。如果非静态类包含需要进行重要的初始化的静态成员，也应定义静态构造函数。